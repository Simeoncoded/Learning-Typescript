Anders Hejlsberg is the lead architect of typescript

Typescript is just a superset of javascript. It includes all the same stuff that javascript includes.
It just adds some fancy stuff on top of it.

The whole point of Typescript is to add static typing to javascript, 

const bootupMessage : string = "";(the string annotation on the bootupMessage variable? Thats telling typescript ,hey the thing 
that follows is a string)

Javascript is dynamic and loosely typed, 

//javascript: 
function add(a, b){
    return a + b;
}

//typescript
function add(a: number, b: number): number {
    return a + b;
}


Typescripts Compiler - TSC

all javascript code is valid typescript
but all typescript code is not valid javascript 

The any type is essentially a type that can literally be anything. It could be a string, a number, a boolean, anything literally.

export const systemPrompt : any = 
    "Your purpose is to help";

export const tokenLimit : any = 1000;
export const hasAdminAccess : any = true;

types in typescript

number, string, boolean, any , symbol, null, undefined

//FUNCTIONS

export function calculateTotal(
    price: number,
    quantity: number,
    discount: number,
) : number {
    return price * quantity * (1 - discount);
}

//void 
The TS-specific void type represents the return value of functions that dont return a value.    
In javascript a function without a return statement returns undefined by default.
Typescript uses the void keyword to indicate thar truely nothing is returned.

//function types
A function's type includes information about its parameters and return value

The syntax for a function type looks lke this 

(param1: type1, param2: type2, ...) => returnType

for example, a function that takes two numbers and returns a number
(a: number, b: number) => number


//IMPORTING TYPES
with certain Typescript configurations you can import types directly from a module

import { User, Post } from "./models";

But its much safer and more efficient to use the import type syntax

import type { User, Post } from "./models";

This way Typescript knows that you are only importing types, and it can drop the imports from the compiled Javascript code.
This syntax also works:

import { type User, type Post } from "./models";

//UNIONS
Union types use the pipe symbol (|) and allow you to specify that a value can be one of several types

//user id is a string OR a number
let userId: string | number
userId = "user_42";
userId = 42;

//OPTIONAL PARAMETERS 
You can specify function parameters as optional with a question mark (?) after the name 

function greet(name: string, title?: string): string {
    if(title){
        return `Hello, ${title} ${name}!`;
    }
    return `Hello, ${name}!`;
}   

There are two rules to keep in mind when using optional parameters:

1. Optional parameters must come after required parameters.


//DEFAULT PARAMETERS
Default parameters provide fallback values for optional arguments.

//LITERAL TYPES
Many other statically typed languages (including Go) don't nearly have nearly as extensive
and powerful type systems as Typescript. It should be obvious because its in the name, but
Typescript truly has a massive type system.

Literal types are incredibly powerful for narrowing the possible values of a variable.

* A string can have an infinite number of values.
* A number can have an infinite number of values.

So what if we want to declare a "direction" variable?


//VALUE UNIONS
Take another look at our last example of a literal type:

function move(direction: "north"){
    //implementation
}

To make it a bit more useful, lets combine that idea with a union type:


function move(direction: "north" | "south" | "east"){
    //implementation
}

And then let's refactor it to make a new "Direction" type that we can reuse:

type Direction = "north" | "south" | "east" | "west";

function move(direction: Direction){
    //Implementation
}

//SUPER SET UNIONS 
So we know we can drastically narrow a primitive type like "number" by using a union of literal types.
For example, maybe only 3 error codes are valid:

type ErrorCodes = 200 | 404 | 500;

This works great if these are the only valid error codes,
but what if:

1. Any number can be used as an error code

//TEMPLATE LITERAL TYPES
This is one of the more unhinged features of TypeScript(at least in my opinion),
but it is really cool and insanely powerful when you find a good use case for it.

Remember literal types and type unions? 

type Class  = "wizard" | "warrior" | "rogue";

Well you can also create literal types using string templates:

type Hero = `elf ${Class}`;

The type of Class expands automatically to the possible values,  so the above is the same as:

type Hero = "elf wizard" | "elf warrior" | "elf rogue";

You can also get crazy and combine all the combinations of two types:

type Class = "wizard" | "warrior" | "rogue";
type Race = "elf" | "human" | "dwarf";  
type Hero = `Hero: ${Race} ${Class}`;

//ARRAYS
The most common common way to declare an array is using the bracket notation, string[], number[], e.t.c.

function trainJedi(jediKnights: string[]){
    for(let knight of jediKnights){
        console.log(`Training ${knight}`);
    }
}

trainJedi(["Dooku", "Qui-Gon", "Xanatos"]);

//TYPE PARAMETERS
Typescript offers an alternative way to declare arrays using type parameter syntax:
Array<T>, which, for now, just know its basically that same as the "normal" T[] syntax.
You'll see both versions in the wild.

These function declarations are the same:

//using bracket notation
function assignLightsaberColors(name: string, colors: string[]): void {
    //...
}

//Using generic type parameter syntax
function assignLightsaberColors(name: string, colors: Array<string>): void {
    //...
}

//HETEROGENEOUS ARRAYS
If you can do it in Javascript, you can model it in Typescript. 
It might not always be pretty... but in this case it is!

In languages like Go, you can't have an array that contains different types - at least
not without using something a bit more complex like a struct or interface. But in 
Typescript, we can just union the types!.

//Typescript infers the type as (string | number)[]
let lightsaberStyles = [1, 2, "double", "shoto"];

function describe(style: string | number): string {
    console.log(`Wield ${style} lightsaber`);
}

lightsaberStyles.map(describe);




//REST PARAMETERS
Rest parameters allow an indefinitte number of final arguments, and brings them into the function
body as an array. They're denoted by three dots(...) before the parameter name.

function gatherParty(partyName: string, ...adventurers: string[]): string {
    return `${partyName} consists of: ${adventurers.join(", ")}`;
}



const msg = gatherParty("The Fellowship", "Frodo", "Sam", "Gandalf");
console.log(msg);
//The Fellowship consists of: Frodo, Sam, Gandalf

