Anders Hejlsberg is the lead architect of typescript

Typescript is just a superset of javascript. It includes all the same stuff that javascript includes.
It just adds some fancy stuff on top of it.

The whole point of Typescript is to add static typing to javascript, 

const bootupMessage : string = "";(the string annotation on the bootupMessage variable? Thats telling typescript ,hey the thing 
that follows is a string)

Javascript is dynamic and loosely typed, 

//javascript: 
function add(a, b){
    return a + b;
}

//typescript
function add(a: number, b: number): number {
    return a + b;
}


Typescripts Compiler - TSC

all javascript code is valid typescript
but all typescript code is not valid javascript 

The any type is essentially a type that can literally be anything. It could be a string, a number, a boolean, anything literally.

export const systemPrompt : any = 
    "Your purpose is to help";

export const tokenLimit : any = 1000;
export const hasAdminAccess : any = true;

types in typescript

number, string, boolean, any , symbol, null, undefined

//FUNCTIONS

export function calculateTotal(
    price: number,
    quantity: number,
    discount: number,
) : number {
    return price * quantity * (1 - discount);
}

//void 
The TS-specific void type represents the return value of functions that dont return a value.    
In javascript a function without a return statement returns undefined by default.
Typescript uses the void keyword to indicate thar truely nothing is returned.

//function types
A function's type includes information about its parameters and return value

The syntax for a function type looks lke this 

(param1: type1, param2: type2, ...) => returnType

for example, a function that takes two numbers and returns a number
(a: number, b: number) => number


//IMPORTING TYPES
with certain Typescript configurations you can import types directly from a module

import { User, Post } from "./models";

But its much safer and more efficient to use the import type syntax

import type { User, Post } from "./models";

This way Typescript knows that you are only importing types, and it can drop the imports from the compiled Javascript code.
This syntax also works:

import { type User, type Post } from "./models";

//UNIONS
Union types use the pipe symbol (|) and allow you to specify that a value can be one of several types

//user id is a string OR a number
let userId: string | number
userId = "user_42";
userId = 42;

//OPTIONAL PARAMETERS 
You can specify function parameters as optional with a question mark (?) after the name 

function greet(name: string, title?: string): string {
    if(title){
        return `Hello, ${title} ${name}!`;
    }
    return `Hello, ${name}!`;
}   

There are two rules to keep in mind when using optional parameters:

1. Optional parameters must come after required parameters.


//DEFAULT PARAMETERS
Default parameters provide fallback values for optional arguments.

//LITERAL TYPES
Many other statically typed languages (including Go) don't nearly have nearly as extensive
and powerful type systems as Typescript. It should be obvious because its in the name, but
Typescript truly has a massive type system.

Literal types are incredibly powerful for narrowing the possible values of a variable.

* A string can have an infinite number of values.
* A number can have an infinite number of values.

So what if we want to declare a "direction" variable?


//VALUE UNIONS
Take another look at our last example of a literal type:

function move(direction: "north"){
    //implementation
}

To make it a bit more useful, lets combine that idea with a union type:


function move(direction: "north" | "south" | "east"){
    //implementation
}

And then let's refactor it to make a new "Direction" type that we can reuse:

type Direction = "north" | "south" | "east" | "west";

function move(direction: Direction){
    //Implementation
}

//SUPER SET UNIONS 
So we know we can drastically narrow a primitive type like "number" by using a union of literal types.
For example, maybe only 3 error codes are valid:

type ErrorCodes = 200 | 404 | 500;

This works great if these are the only valid error codes,
but what if:

1. Any number can be used as an error code

//TEMPLATE LITERAL TYPES
This is one of the more unhinged features of TypeScript(at least in my opinion),
but it is really cool and insanely powerful when you find a good use case for it.

Remember literal types and type unions? 

type Class  = "wizard" | "warrior" | "rogue";

Well you can also create literal types using string templates:

type Hero = `elf ${Class}`;

The type of Class expands automatically to the possible values,  so the above is the same as:

type Hero = "elf wizard" | "elf warrior" | "elf rogue";

You can also get crazy and combine all the combinations of two types:

type Class = "wizard" | "warrior" | "rogue";
type Race = "elf" | "human" | "dwarf";  
type Hero = `Hero: ${Race} ${Class}`;

//ARRAYS
The most common common way to declare an array is using the bracket notation, string[], number[], e.t.c.

function trainJedi(jediKnights: string[]){
    for(let knight of jediKnights){
        console.log(`Training ${knight}`);
    }
}

trainJedi(["Dooku", "Qui-Gon", "Xanatos"]);

//TYPE PARAMETERS
Typescript offers an alternative way to declare arrays using type parameter syntax:
Array<T>, which, for now, just know its basically that same as the "normal" T[] syntax.
You'll see both versions in the wild.

These function declarations are the same:

//using bracket notation
function assignLightsaberColors(name: string, colors: string[]): void {
    //...
}

//Using generic type parameter syntax
function assignLightsaberColors(name: string, colors: Array<string>): void {
    //...
}

//HETEROGENEOUS ARRAYS
If you can do it in Javascript, you can model it in Typescript. 
It might not always be pretty... but in this case it is!

In languages like Go, you can't have an array that contains different types - at least
not without using something a bit more complex like a struct or interface. But in 
Typescript, we can just union the types!.

//Typescript infers the type as (string | number)[]
let lightsaberStyles = [1, 2, "double", "shoto"];

function describe(style: string | number): string {
    console.log(`Wield ${style} lightsaber`);
}

lightsaberStyles.map(describe);




//REST PARAMETERS
Rest parameters allow an indefinitte number of final arguments, and brings them into the function
body as an array. They're denoted by three dots(...) before the parameter name.

function gatherParty(partyName: string, ...adventurers: string[]): string {
    return `${partyName} consists of: ${adventurers.join(", ")}`;
}



const msg = gatherParty("The Fellowship", "Frodo", "Sam", "Gandalf");
console.log(msg);
//The Fellowship consists of: Frodo, Sam, Gandalf


//Evolving Any
When you create a new empty array, TypeScript infers it as any[].

let inventory = [];
//inventory: any[]

If you then push a type into it, TypeScript will infer the array as that type
inventory.push(42);
//inventory: number[]

//OBJECTS
When it comes to the most useful upgrade from Javascript to Typescript, 
its adding types to objects.

Object Literal  types allow you to describe the shape of an object.

function logSaiyan(saiyan: { name:string; power:number }{
    console.log(`${saiyan.name} has power level: ${saiyan.power})
})

//EXTRA PROPERTIES
Most of the time, when you pass an object to a function in typescript, its:

1. Ok to have more properties than those defined in the functions parameter type.
2. Not ok to have missing properties

However, when you have an object literal type directly to a function, Typescript
performs whats called "excess property checking". which means it also will now allow extra properties   


//OPTIONAL OBJECT PROPERTIES
The following is used way more often than most of us would like, but it is incredibly useful. Optional properties
can be added to an object type with the ? operator:

type Superhero = {
    name: string;
    strength: number;
    cape?: boolean; //cape is optional
}

That means the type of .cape is actually boolean | undefined, just like optional function parameters.

//EMPTY OBJECT TYPE
Say i innocently create a new empty object :

let newUser = {};

Then go to add  properties to it later:

//Property 'name' does not exist on type '{}'
newUser.name = "Lane";

TypeScript doesnt like that !
It makes sense, we never told TypeScript which properties to allow... but here's what's really crazy: 
this is actually allowed:

let newUser = {};
newUser = "Lane";

//DISCRIMINATED UNIONS
A union of two primitive types, like string | number, is really simple: its a string or a number. 
The same is true of object types, but it can be tricky to know which type you're dealing with. Thats where
"discriminant properties" (or "tags") come in handy. Its just a property that tells you which type you are dealing
with, and makes it easy to use conditional logic to handle each type. What is special about is it can be onl one value.

Unions of objects with a discriminant property are called "discriminited unions" or "tagged unions".

type MultipleChoiceLesson = {
    kind: "multiple-choice"; //discriminant property
    question: string;
    studentAnswer: string;
    correctAnswer: string;
};

type CodingLesson = {
    kind: "coding"; //Disciminant property
    studentCode: string;
    solutionCode: string;
};

type Lesson = MultipleChoiceLesson | CodingLesson;

function isCorrect(lesson: Lesson): boolean {
    switch(lesson.kind){
        case "multiple-choice:
            return lesson.studentAnswer === lesson.correctAnswer;
        case "coding":
            return lesson.studentAnswer === lesson.solutionCode;
    }
}


//SETS
TypeScript has a built-in type for sets, which are collections of unique values. 
You can ensure that all the values in the set are of the same type by specifying a 
type parameter.: <T>

//A Set that contains only strings
const justiceLeague = new Set<string>();

justiceLeague.add("Green Arrow");
justiceLeague.add("Flash");

//Error: Argument of type '2' is not assignable
justiceLeague.add(2);

//MAPS  
TypeScript(obviously) also has a built-in for maps, which are collection of key-value pairs. You can specify the types
 of the keys and values using type parameters<K, V>.


//DYNAMIC KEYS
Sometimes, you won't know all of an object's property names in advance. 
For example, say you are building a customer management system where 
employees can add custom key/value pairs to customer records:

-favoriteColor: "blue"
-favoriteFood: "pizza"
-favoriteAnimal: "cat"
-etc

You cant know what the user will add ahead of time, but you still want to model the data in your program.


You can define dynamic keys using an index signature

type UserMetrics = {
    [key: string]:  number;
};

This type says "this object can have any number of properties if the keys are strings and the values are numbers.

//DYNAMIC DEFAULT PROPERTIES
So there's this(seemingly) weird but useful thing that you'll see in the wild 

type FormData = {
    [field: string]: string;
    email: string;  //required
    password: string; //required
};

If you are concerned about is which types are allowed in the object, you might wonder why email
and password are even there. After all, you can specify any string key/value pairs in this type, right?

You use this syntax to require certain properties, in this case, email and password

//PROPERTYKEY
With dynamic property keys we've only used the string type so far, and most of the time, 
thats all you need.
However, Javascript also supports number and symbols as property keys.
Typescript actually has a built-in type called PropertyKey thar represents all possible key types:

//this is a built-in type
type PropertyKey = string | number | symbol;


### A symbol is a unique and immutable data type that may be used as an object property name. It's  kinds like a string, 
but its guaranteed to be unique.

//READONLY MODIFIER
The readonly modifier is very similar to the const keyword in Javascript.
Its an addded feature of TypeScript that lets us mark object properties as read-only, meaning they can't be
 changed after initialization.

 Normal object properties are fully mutable, but if we use readonly, we can make a propery immutable:

 type Point = {
    readonly x: number;
    y: number;
 };


 //AS Const and Object.Freeze
The as const assertion creates a readonly type using literal values:

const colorsConst = ['red', 'green', 'blue'] as const;

//Error: Property 'push' does not exist on type 'readonly'
colorsConst.push("yellow");

It works greate with objects too, and unlike most utility types and Object.freeze(),
it automatically makes all nested structures readonly as Well:

Object.freeze() is a way in javascript to say that an object is immutable at least at the top
level. So it doesnt work on nesting,but it works at the top level.

const configConst = {
    apiUrl: "https://api.cobrakai.com",
    admins: {
        johnny: "lawrence",
        daniel: "larusso",
    },
    features: ["no mercy", "not crying", "winning too much"],
} as const;

//Error: Cannot assign to 'apiUrl' because it is readonly
configConst.apiUrl = "https://api.karate.com";

//Error: Cannot assign to 'johnny' because it is readonly
configConst.admins.johnny = "larusso";

//Error: Property 'push' does not exist on type 'readonly'
configConst.features.push("sweep the leg");

Object.freeze()
The Object.freeze() method is a built-in Javascript function that prevents modifications
to the top level of an object at runtime. It makes the object immutable, but it does not 
affect TypeScript's type system.

const configConst = Object.freeze({
    apiUrl: "https://api.cobrakai.com",
    admins: {
        johnny: "lawrence",
        daniel: "larusso",
    },
    features: ["no mercy", "not crying", "winning too much"],
});

//Error: Cannot assign to 'apiUrl' because it is readonly
configConst.apiUrl = "https://api.karate.com";

//This is fine because nested properties are not frozen
configConst.admins.johnny = "kreese";

//This is also fine because the array is not frozen
configConst.features.push("sweep the leg");


//SATISFIES
The satisfies operator validates that a value matches a specific type without changing it inferred type.
It solves a common pain point in TypeScript's type system. Before satisfies, you often had to choose between:

1.Letting TypeScript infer types(good for flexbility, but might miss errors)
2.Using explicit type annotations(good for catching errors, but loses literal information)


//FUNCTION OVERLOAD 
Javascript is very lenient when it comes to function signatures, and Typescript gives us a way to take
advantage of that flexbility while still maintaining type safety: function overloads.

First, we define a function that can be called in multiple ways:

function formatEmployeeMessage(
    employee : Employee,
    isNew?: boolean,
    onBoardedDate? : Date,
): string {
    if(!isNew){
        return `Employee: ${employee.name}, Dept: ${employee.department}`;
    }
    return `Employee: ${employee.name}, New: Yes, onboarded
}

Used as-is, this function can be called in 3 different ways:    
formatEmployeeMessage(employee)
formatEmployeeMessage(employee, boolean)
formatEmployeeMessage(employee, boolean, Date)

But we can constrain the function to only allow certain combinations 
of parameters by using functino overloads.
